# SGEMM V4 - 寄存器缓存优化版本 计算逻辑图

## 核心算法

**目标**：使用寄存器数组模拟二级缓存，减少共享内存访问，提高计算密度

## 假设参数
- 矩阵A: 8×8, 矩阵B: 8×8, 矩阵C: 8×8  
- BLOCK_SIZE = 4 (为了简化图示)
- THREAD_TILE_M = 4, THREAD_TILE_N = 4 (每个线程计算4×4子块)
- Block配置: (1×1), Grid配置: (2×2)

## 寄存器缓存策略详解

### 内存层次结构
```
全局内存 (高延迟)
    ↓
共享内存 (中等延迟) 
    ↓  
寄存器缓存 (最低延迟) ← V4版本的核心优化
    ↓
计算单元
```

### 寄存器使用分配
```
每个线程的寄存器分配:
┌─────────────────┬──────────┬─────────────────┐
│   寄存器数组    │   大小   │      用途       │
├─────────────────┼──────────┼─────────────────┤
│ reg_C[4][4]     │   16     │ 存储C的4×4子块  │
│ reg_A[4]        │    4     │ 缓存A的行数据   │
│ reg_B[4]        │    4     │ 缓存B的列数据   │
│ 其他临时变量    │   ~8     │ 索引、循环变量  │
└─────────────────┴──────────┴─────────────────┘
总寄存器使用: ~32个 (每个线程)
```

## 详细计算过程

### Block(0,0)的线程T(0,0)计算过程

#### 线程分工策略
```
Block(0,0)包含1个线程T(0,0):
- 负责计算C[0:4][0:4]的16个元素
- 使用4×4寄存器数组reg_C存储中间结果

线程T(0,0)的计算范围:
┌─────┬─────┬─────┬─────┐
│C[0,0]│C[0,1]│C[0,2]│C[0,3]│
├─────┼─────┼─────┼─────┤
│C[1,0]│C[1,1]│C[1,2]│C[1,3]│
├─────┼─────┼─────┼─────┤
│C[2,0]│C[2,1]│C[2,2]│C[2,3]│
├─────┼─────┼─────┼─────┤
│C[3,0]│C[3,1]│C[3,2]│C[3,3]│
└─────┴─────┴─────┴─────┘
```

#### 窗口0 (tile_k=0): 处理K∈[0,3]

##### 阶段1: 数据加载到共享内存
```
加载A[0:4][0:4]到A_shared:
┌─────┬─────┬─────┬─────┐
│A[0,0]│A[0,1]│A[0,2]│A[0,3]│
├─────┼─────┼─────┼─────┤
│A[1,0]│A[1,1]│A[1,2]│A[1,3]│
├─────┼─────┼─────┼─────┤
│A[2,0]│A[2,1]│A[2,2]│A[2,3]│
├─────┼─────┼─────┼─────┤
│A[3,0]│A[3,1]│A[3,2]│A[3,3]│
└─────┴─────┴─────┴─────┘

加载B[0:4][0:4]到B_shared:
┌─────┬─────┬─────┬─────┐
│B[0,0]│B[0,1]│B[0,2]│B[0,3]│
├─────┼─────┼─────┼─────┤
│B[1,0]│B[1,1]│B[1,2]│B[1,3]│
├─────┼─────┼─────┼─────┤
│B[2,0]│B[2,1]│B[2,2]│B[2,3]│
├─────┼─────┼─────┼─────┤
│B[3,0]│B[3,1]│B[3,2]│B[3,3]│
└─────┴─────┴─────┴─────┘
```

##### 阶段2: 寄存器缓存优化计算 (k=0)

###### 步骤1: 缓存A数据到寄存器
```
从共享内存A_shared[:,0]加载到reg_A:
reg_A[0] = A_shared[0][0] = A[0,0]
reg_A[1] = A_shared[1][0] = A[1,0]  
reg_A[2] = A_shared[2][0] = A[2,0]
reg_A[3] = A_shared[3][0] = A[3,0]

寄存器状态:
reg_A: [A[0,0], A[1,0], A[2,0], A[3,0]]
```

###### 步骤2: 缓存B数据到寄存器
```
从共享内存B_shared[0,:]加载到reg_B:
reg_B[0] = B_shared[0][0] = B[0,0]
reg_B[1] = B_shared[0][1] = B[0,1]
reg_B[2] = B_shared[0][2] = B[0,2]  
reg_B[3] = B_shared[0][3] = B[0,3]

寄存器状态:
reg_B: [B[0,0], B[0,1], B[0,2], B[0,3]]
```

###### 步骤3: 寄存器间计算 (外积运算)
```
使用寄存器数据计算4×4外积:
for tm in [0,1,2,3]:
    for tn in [0,1,2,3]:
        reg_C[tm][tn] += reg_A[tm] * reg_B[tn]

具体计算:
reg_C[0][0] += A[0,0] * B[0,0]
reg_C[0][1] += A[0,0] * B[0,1]  
reg_C[0][2] += A[0,0] * B[0,2]
reg_C[0][3] += A[0,0] * B[0,3]
reg_C[1][0] += A[1,0] * B[0,0]
reg_C[1][1] += A[1,0] * B[0,1]
... (总共16次乘加运算)
```

##### 重复k=1,2,3的计算
```
k=1: 使用A_shared[:,1]和B_shared[1,:]
k=2: 使用A_shared[:,2]和B_shared[2,:]  
k=3: 使用A_shared[:,3]和B_shared[3,:]

每次都是: 共享内存→寄存器→计算→累加到reg_C
```

#### 窗口1 (tile_k=4): 处理K∈[4,7]
```
重复相同的过程:
1. 加载A[0:4][4:8]和B[4:8][0:4]到共享内存
2. 对k=0,1,2,3执行寄存器缓存计算
3. 累加结果到reg_C (最终包含所有K维度的贡献)
```

#### 最终写回
```
将reg_C的16个元素写回全局内存:
C[0][0] = reg_C[0][0], C[0][1] = reg_C[0][1], ...
C[3][3] = reg_C[3][3]
```

## 寄存器缓存的优势分析

### 内存访问模式对比

#### V3版本 (共享内存访问)
```
每个k迭代的内存访问:
1. 读取A_shared[tm][k]: 4次共享内存访问
2. 读取B_shared[k][tn]: 4次共享内存访问  
3. 计算16次乘加运算
总计: 每个k需要8次共享内存访问

窗口内总访问: 8次/k × 4个k = 32次共享内存访问
```

#### V4版本 (寄存器缓存)
```
每个k迭代的内存访问:
1. 读取A_shared[:,k]到reg_A: 4次共享内存访问
2. 读取B_shared[k,:]到reg_B: 4次共享内存访问
3. 寄存器间计算: 16次乘加 (0次内存访问)
总计: 每个k需要8次共享内存访问

但是! 4个A值和4个B值被复用16次计算
数据复用率: 16/8 = 2倍提升
```

### 计算密度提升
```
V3版本计算密度:
- 16次乘加运算需要32次内存访问
- 计算/内存比 = 16/32 = 0.5

V4版本计算密度:  
- 16次乘加运算需要8次内存访问
- 计算/内存比 = 16/8 = 2.0
- 提升4倍计算密度
```

## 寄存器使用优化策略

### 外积运算模式
```
传统点积模式 (V1-V3):
C[i][j] = Σ(A[i][k] * B[k][j])  // 逐个元素计算

寄存器外积模式 (V4):
reg_C[4×4] += reg_A[4×1] ⊗ reg_B[1×4]  // 批量外积运算

优势:
1. 数据复用率高: 每个A[i][k]被复用4次，每个B[k][j]被复用4次
2. 寄存器访问: 延迟仅1-2个周期 vs 共享内存20周期
3. 指令级并行: 外积运算可以并行执行
```

### 寄存器分配策略
```
reg_C[4][4]: 累加器数组 (持久保存)
reg_A[4]: 临时缓存 (每个k更新)  
reg_B[4]: 临时缓存 (每个k更新)

内存访问层次:
全局内存 → 共享内存 → 寄存器 → ALU
  400周期    20周期     1周期   1周期
```
